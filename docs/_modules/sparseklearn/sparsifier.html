
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>sparseklearn.sparsifier &#8212; sparseklearn 0.1.4 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for sparseklearn.sparsifier</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">sparse</span>
<span class="kn">from</span> <span class="nn">scipy.fftpack</span> <span class="k">import</span> <span class="n">dct</span><span class="p">,</span> <span class="n">idct</span>
<span class="kn">from</span> <span class="nn">numpy.ctypeslib</span> <span class="k">import</span> <span class="n">ndpointer</span>
<span class="kn">import</span> <span class="nn">ctypes</span> <span class="k">as</span> <span class="nn">ct</span>

<span class="kn">from</span> <span class="nn">sparseklearn.fastLA</span> <span class="k">import</span> <span class="n">pairwise_l2_distances_with_self</span>
<span class="kn">from</span> <span class="nn">sparseklearn.fastLA</span> <span class="k">import</span> <span class="n">pairwise_l2_distances_with_full</span>
<span class="kn">from</span> <span class="nn">sparseklearn.fastLA</span> <span class="k">import</span> <span class="n">compute_weighted_first_moment_array</span>
<span class="kn">from</span> <span class="nn">sparseklearn.fastLA</span> <span class="k">import</span> <span class="n">compute_weighted_first_and_second_moment_array</span>

<span class="kn">from</span> <span class="nn">sparseklearn.fastLA</span> <span class="k">import</span> <span class="n">pairwise_mahalanobis_distances_spherical</span>
<span class="kn">from</span> <span class="nn">sparseklearn.fastLA</span> <span class="k">import</span> <span class="n">pairwise_mahalanobis_distances_diagonal</span>

<div class="viewcode-block" id="Sparsifier"><a class="viewcode-back" href="../../sparsifier.html#sparseklearn.sparsifier.Sparsifier">[docs]</a><span class="k">class</span> <span class="nc">Sparsifier</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Sparsifier.</span>

<span class="sd">    Compresses data through sparsification. Permits several operations on</span>
<span class="sd">    sparsified data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_feat_full : int</span>
<span class="sd">        Dimension of a full sample.</span>

<span class="sd">    num_feat_comp : int</span>
<span class="sd">        The number of dimensions to keep in the compressed data.</span>

<span class="sd">    num_samp : int</span>
<span class="sd">        The number of samples in the dataset.</span>

<span class="sd">    transform : {&#39;dct&#39;, None}, defaults to &#39;dct&#39;.</span>
<span class="sd">        The preconditioning transform.</span>
<span class="sd">        Determines what form of H to use in the preconditioning transform HD.</span>
<span class="sd">        Any method other than None will also use the diagonal D matrix (which</span>
<span class="sd">        can be set using the D_indices parameter). The direct cosine transform</span>
<span class="sd">        is currently the only method supported (&#39;dct&#39;).</span>

<span class="sd">    mask : np.ndarray, shape (n_datapoints, dim_mask), optional</span>
<span class="sd">        defaults to None. The user-provided mask. If None, mask is</span>
<span class="sd">        generated using the generate_mask method.</span>

<span class="sd">    num_feat_shared : int, defaults to 0.</span>
<span class="sd">        The minimum number of dimensions to be shared across all samples in the</span>
<span class="sd">        compressed data.</span>

<span class="sd">    D_indices : np.ndarray, shape (n_datapoints,), optional</span>
<span class="sd">        defaults to None. The user-provided diagonal of the preconditioning matrix D.</span>
<span class="sd">        If None, generated using the generate_D_indices method.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    mask : np.ndarray, shape (num_samp, num_feat_comp)</span>
<span class="sd">        The mask used to sparsify the data. Array of integers, each row is the</span>
<span class="sd">        indices specifying which entries that sample were kept.</span>

<span class="sd">    D_indices : np.ndarray, shape (n_signflips,)</span>
<span class="sd">        Defines the preconditioning matrix D. Array of integers,</span>
<span class="sd">        the indices of the preconditioning matrix D with sign -1.</span>

<span class="sd">    &quot;&quot;&quot;</span>



    <span class="c1">###########################################################################</span>
    <span class="c1"># Preconditoning and mask generation</span>

    <span class="k">def</span> <span class="nf">_generate_D_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Randomly generate the D matrix in the HD transform. Store only the</span>
<span class="sd">        indices where D == -1. &quot;&quot;&quot;</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
        <span class="k">if</span> <span class="n">transform</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;dct&#39;</span><span class="p">]:</span>
            <span class="n">D_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_feat_full</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])])</span>
        <span class="k">elif</span> <span class="n">transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">D_indices</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">D_indices</span>

    <span class="k">def</span> <span class="nf">_generate_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a sparsifying mask.&quot;&quot;&quot;</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
        <span class="c1"># pick the shared indices</span>
        <span class="n">all_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_feat_full</span><span class="p">))</span>
        <span class="n">rng</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">all_indices</span><span class="p">)</span>
        <span class="n">shared_mask</span> <span class="o">=</span> <span class="n">all_indices</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">num_feat_shared</span><span class="p">]</span>
        <span class="c1"># pick what&#39;s left randomly</span>
        <span class="n">remaining_indices</span> <span class="o">=</span> <span class="n">all_indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_feat_shared</span><span class="p">:]</span>
        <span class="n">num_left_to_draw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_comp</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_shared</span>
        <span class="k">if</span> <span class="n">num_left_to_draw</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">random_masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">remaining_indices</span><span class="p">,</span>
                <span class="n">num_left_to_draw</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">)]</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">random_masks</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">shared_mask</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># then all dimensions are shared</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">shared_mask</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">mask</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mask</span>

    <span class="c1">###########################################################################</span>
    <span class="c1"># Transform and masking tools</span>

<div class="viewcode-block" id="Sparsifier.apply_mask"><a class="viewcode-back" href="../../sparsifier.html#sparseklearn.sparsifier.Sparsifier.apply_mask">[docs]</a>    <span class="k">def</span> <span class="nf">apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Apply the mask to X.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        X : np.ndarray, shape(n, P)</span>
<span class="sd">        mask : np.ndarray, shape(n, Q)</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        RX : np.ndarray, shape(n, Q)</span>
<span class="sd">            Masked X. The nth row of RX is X[n][mask[n]].</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
        <span class="k">return</span> <span class="n">X_masked</span></div>

<div class="viewcode-block" id="Sparsifier.apply_HD"><a class="viewcode-back" href="../../sparsifier.html#sparseklearn.sparsifier.Sparsifier.apply_HD">[docs]</a>    <span class="k">def</span> <span class="nf">apply_HD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Apply the preconditioning transform to X.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        X : np.ndarray, shape (n, P)</span>
<span class="sd">            The data to precondition. Each row is a datapoint.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        HDX : np.ndarray, shape (n, P)</span>
<span class="sd">            The transformed data.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># copy it for now</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="c1"># apply D matrix</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Y</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">D_indices</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="c1"># apply H matrix</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">==</span> <span class="s1">&#39;dct&#39;</span><span class="p">:</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">dct</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">norm</span> <span class="o">=</span> <span class="s1">&#39;ortho&#39;</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">overwrite_x</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Y</span></div>

<div class="viewcode-block" id="Sparsifier.invert_HD"><a class="viewcode-back" href="../../sparsifier.html#sparseklearn.sparsifier.Sparsifier.invert_HD">[docs]</a>    <span class="k">def</span> <span class="nf">invert_HD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">HDX</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Apply the inverse of HD to HDX.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        HDX : np.ndarray, shape (n, P)</span>
<span class="sd">            The preconditioned data. Each row is a datapoint.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        X : np.ndarray, shape (n, P)</span>
<span class="sd">            The raw data.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">HDX</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">idct</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">norm</span> <span class="o">=</span> <span class="s1">&#39;ortho&#39;</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">overwrite_x</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">X</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">D_indices</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">X</span></div>

<div class="viewcode-block" id="Sparsifier.invert_mask_bool"><a class="viewcode-back" href="../../sparsifier.html#sparseklearn.sparsifier.Sparsifier.invert_mask_bool">[docs]</a>    <span class="k">def</span> <span class="nf">invert_mask_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute the mask inverse.</span>

<span class="sd">        The mask is an array indicating which dimensions are kept for each</span>
<span class="sd">        data point. The inverse mask is an array indicating which datapoints</span>
<span class="sd">        keep this dimension, for each dimension. For computational efficiency,</span>
<span class="sd">        the inverse mask is given as a sparse boolean array whereas the mask</span>
<span class="sd">        is a (smaller) dense integer array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        mask_inverse : sparse.csr_matrix, bool, shape (P,N)</span>
<span class="sd">            The mask inverse. The ij entry is 1 if the jth datapoint</span>
<span class="sd">            keeps the ith dimension under the mask, and 0 otherwise;</span>
<span class="sd">            in other words, 1 if i is in the list mask[j].</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">col_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_feat_comp</span><span class="p">)]</span>
        <span class="n">row_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">row_inds</span><span class="p">)</span>
        <span class="n">mask_binary</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">row_inds</span><span class="p">,</span> <span class="n">col_inds</span><span class="p">)),</span>
                      <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_feat_full</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mask_binary</span></div>

    <span class="k">def</span> <span class="nf">_set_RHDX</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">HDX</span><span class="p">,</span> <span class="n">RHDX</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Wrapper to compute RHDX from HDX or assign it if user-specified. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">RHDX</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">RHDX</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">HDX</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">HDX</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_X</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;X must be a 2D array.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;X must have num_samp = </span><span class="si">{self.num_samp}</span><span class="s2"> rows, but has </span><span class="si">{X.shape[0]}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_full</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;X must have num_feat_full = </span><span class="si">{self.num_feat_full}</span><span class="s2"> columns, but has </span><span class="si">{X.shape[1]}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_HDX</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">HDX</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">HDX</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">HDX</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;HDX must be a 2D array.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">HDX</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;HDX must have num_samp = </span><span class="si">{self.num_samp}</span><span class="s2"> rows, but has </span><span class="si">{HDX.shape[0]}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">HDX</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_full</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;HDX must have num_feat_full = </span><span class="si">{self.num_feat_full}</span><span class="s2"> columns, but has </span><span class="si">{HDX.shape[1]}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_RHDX</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">RHDX</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">RHDX</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">RHDX</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;RHDX must be a 2D array.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">RHDX</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;RHDX must have num_samp = </span><span class="si">{self.num_samp}</span><span class="s2"> rows, but has </span><span class="si">{RHDX.shape[0]}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">RHDX</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_comp</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;RHDX must have num_feat_full = </span><span class="si">{self.num_feat_comp}</span><span class="s2"> columns, but has </span><span class="si">{RHDX.shape[1]}</span><span class="s2">.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Sparsifier.fit_sparsifier"><a class="viewcode-back" href="../../sparsifier.html#sparseklearn.sparsifier.Sparsifier.fit_sparsifier">[docs]</a>    <span class="k">def</span> <span class="nf">fit_sparsifier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">HDX</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">RHDX</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot; Fit the sparsifier to specified data.</span>

<span class="sd">        Sets self.RHDX, the sumsampled, preconditioned data.</span>
<span class="sd">        At least one of the parameters must be set. If RHDX is passed,</span>
<span class="sd">        then X and HDX are ignored. If HDX is passed, then X is ignored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        X : np.ndarray, shape (num_samp, num_feat_full), defaults to None.</span>
<span class="sd">            Dense, raw data.</span>

<span class="sd">        HDX : np.ndarray, shape (num_samp, num_feat_full), defaults to None.</span>
<span class="sd">            Dense, preconditioned data.</span>

<span class="sd">        RHDX : np.ndarray, shape (num_samp, num_feat_comp), defaults to None.</span>
<span class="sd">            Subsampled, preconditioned data.</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="k">if</span> <span class="n">HDX</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">RHDX</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_X</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">RHDX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apply_HD</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">HDX</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">RHDX</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_HDX</span><span class="p">(</span><span class="n">HDX</span><span class="p">)</span>
            <span class="n">RHDX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">HDX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">RHDX</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_RHDX</span><span class="p">(</span><span class="n">RHDX</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Must pass at least one of H, HDX, or RHDX.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">RHDX</span> <span class="o">=</span> <span class="n">RHDX</span></div>

    <span class="c1">###########################################################################</span>
    <span class="c1"># Operations on masked data</span>

<div class="viewcode-block" id="Sparsifier.pairwise_distances"><a class="viewcode-back" href="../../sparsifier.html#sparseklearn.sparsifier.Sparsifier.pairwise_distances">[docs]</a>    <span class="k">def</span> <span class="nf">pairwise_distances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes the pairwise distance between each sparsified sample,</span>
<span class="sd">        or between each sparsified sample and each full sample in Y if</span>
<span class="sd">        Y is given.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Y : np.ndarray, shape (K, P), optional</span>
<span class="sd">            defaults to None. Full, transformed samples.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        distances : np.ndarray, shape(K or N, N)</span>
<span class="sd">            distances between each pair of samples (if Y is None) or distances</span>
<span class="sd">            between each sample and each row in Y.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">Y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">pairwise_l2_distances_with_self</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">RHDX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_comp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_full</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">,</span> <span class="n">K</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">pairwise_l2_distances_with_full</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">RHDX</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_comp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_full</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Sparsifier.weighted_means"><a class="viewcode-back" href="../../sparsifier.html#sparseklearn.sparsifier.Sparsifier.weighted_means">[docs]</a>    <span class="k">def</span> <span class="nf">weighted_means</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">W</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes weighted full means of sparsified samples. Currently this</span>
<span class="sd">        is also used to compute hard assignments but should be updated for</span>
<span class="sd">        speed later - zeros in W are multiplied through.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        W : np.ndarray, shape (N, K)</span>
<span class="sd">            Weights. Each row corresponds to a sample, each column to a set of</span>
<span class="sd">            weights. The columns of W should sum to 1. There is no necessary</span>
<span class="sd">            correspondence between the columns of W.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        means : np.ndarray, shape (K,P)</span>
<span class="sd">            Weighted full means. Each row corresponds to a possible independent</span>
<span class="sd">            set of weights (for example, a binary W with K columns would give</span>
<span class="sd">            the means of K clusters).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">W</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_full</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">compute_weighted_first_moment_array</span><span class="p">(</span>
                               <span class="n">means</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">RHDX</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span>
                               <span class="n">W</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">,</span>
                               <span class="n">K</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_comp</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_full</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">means</span></div>

<div class="viewcode-block" id="Sparsifier.weighted_means_and_variances"><a class="viewcode-back" href="../../sparsifier.html#sparseklearn.sparsifier.Sparsifier.weighted_means_and_variances">[docs]</a>    <span class="k">def</span> <span class="nf">weighted_means_and_variances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">W</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes weighted full means and variances of sparsified samples.</span>
<span class="sd">        Currently also used to compute hard assignments but should be updated</span>
<span class="sd">        for speed later - zeros in W are multiplied through.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        W : np.ndarray, shape (N, K)</span>
<span class="sd">            Weights. Each row corresponds to a sample, each column to a set of</span>
<span class="sd">            weights. The columns of W should sum to 1. There is no necessary</span>
<span class="sd">            correspondence between the columns of W.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        means : np.ndarray, shape (K,P)</span>
<span class="sd">            Weighted full means. Each row corresponds to a possible independent</span>
<span class="sd">            set of weights (for example, a binary W with K columns would give</span>
<span class="sd">            the means of K clusters).</span>

<span class="sd">        variances : np.ndarray, shape (K,P)</span>
<span class="sd">            Weighted full variances. Each row corresponds to a possible independent</span>
<span class="sd">            set of weights (for example, a binary W with K columns would give</span>
<span class="sd">            the variances of K clusters).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">W</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_full</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">second_moments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_full</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">compute_weighted_first_and_second_moment_array</span><span class="p">(</span>
                               <span class="n">means</span><span class="p">,</span>
                               <span class="n">second_moments</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">RHDX</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span>
                               <span class="n">W</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">,</span>
                               <span class="n">K</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_comp</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_full</span><span class="p">)</span>
        <span class="n">variances</span> <span class="o">=</span> <span class="n">second_moments</span> <span class="o">-</span> <span class="n">means</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">return</span><span class="p">[</span><span class="n">means</span><span class="p">,</span> <span class="n">variances</span><span class="p">]</span></div>

<div class="viewcode-block" id="Sparsifier.pairwise_mahalanobis_distances"><a class="viewcode-back" href="../../sparsifier.html#sparseklearn.sparsifier.Sparsifier.pairwise_mahalanobis_distances">[docs]</a>    <span class="k">def</span> <span class="nf">pairwise_mahalanobis_distances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">means</span><span class="p">,</span> <span class="n">covariances</span><span class="p">,</span> <span class="n">covariance_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes the mahalanobis distance between each compressed sample and</span>
<span class="sd">        each full mean (each row of means).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        means : np.ndarray, shape (K,P)</span>
<span class="sd">            The means with which to take the mahalanobis distances. Each row of</span>
<span class="sd">            means is a single mean in P-dimensional space.</span>

<span class="sd">        covariances : np.ndarray, shape (K,P) or shape (P,).</span>
<span class="sd">            The non-zero entries of the covariance matrix. If</span>
<span class="sd">            covariance_type is &#39;spherical&#39;, must be shape (P,). If</span>
<span class="sd">            covariance_type is &#39;diag&#39;, must be shape (K,P)</span>

<span class="sd">        covariance_type : {&#39;spherical&#39;, &#39;diag&#39;}, string.</span>
<span class="sd">            The form of the covariance matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        distances : np.ndarray, shape (N,K)</span>
<span class="sd">            The pairwise mahalanobis distances.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO check that means is 2D and it has number of columns == self.num_feat_full</span>
        <span class="c1">#TODO check that covariances is the right shape for each case</span>
        <span class="c1">#TODO add a test to catch the exception</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">means</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">,</span> <span class="n">K</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">covariance_type</span> <span class="o">==</span> <span class="s1">&#39;spherical&#39;</span><span class="p">:</span>
            <span class="n">pairwise_mahalanobis_distances_spherical</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">RHDX</span><span class="p">,</span>
                                                     <span class="n">means</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span>
                                                     <span class="n">covariances</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">,</span>
                                                     <span class="n">K</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_comp</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_full</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">covariance_type</span> <span class="o">==</span> <span class="s1">&#39;diag&#39;</span><span class="p">:</span>
            <span class="n">pairwise_mahalanobis_distances_diagonal</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">RHDX</span><span class="p">,</span>
                                                    <span class="n">means</span><span class="p">,</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span>
                                                    <span class="n">covariances</span><span class="p">,</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">,</span>
                                                    <span class="n">K</span><span class="p">,</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_comp</span><span class="p">,</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_full</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;covariance_type must be &#39;spherical&#39; or &#39;diag&#39;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">distances</span></div>


    <span class="k">def</span> <span class="nf">_pick_K_dense_datapoints_kmpp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Picks K datapoints randomly according to the kmpp method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        K : int</span>
<span class="sd">            The number of datapoints to pick.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        datapoints : np.ndarray, shape (K,P)</span>
<span class="sd">            Each row is a point in dense space. If HDX is given,</span>
<span class="sd">            uses this. Otherwise, maps RHDX to dense space and fills in zeros.</span>

<span class="sd">        datapoint_indices : np.ndarray, shape (K,)</span>
<span class="sd">            The indices of the datapoints in self.X.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
        <span class="n">datapoint_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">datapoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_full</span><span class="p">))</span>

        <span class="c1"># pick the first one at random from the data</span>
        <span class="n">datapoint_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">)</span>
        <span class="n">datapoints</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">datapoint_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">RHDX</span><span class="p">[</span><span class="n">datapoint_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="c1"># initialize the previous distance counter to max float</span>
        <span class="c1"># (so it&#39;s guaranteed to be overwritten in the loop)</span>
        <span class="n">d_prev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>

        <span class="c1"># now pick the remaining k-1 cluster_centers</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">K</span><span class="p">):</span>
            <span class="c1"># squared distance from all the data points to the last cluster added</span>
            <span class="n">latest_cluster</span> <span class="o">=</span> <span class="n">datapoints</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">d_curr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pairwise_distances</span><span class="p">(</span><span class="n">Y</span> <span class="o">=</span> <span class="n">latest_cluster</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
            <span class="c1"># ||x - U|| is either this distance or the current minimum</span>
            <span class="n">where_we_have_not_improved</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">d_curr</span> <span class="o">&gt;</span> <span class="n">d_prev</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">d_curr</span><span class="p">[</span><span class="n">where_we_have_not_improved</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_prev</span><span class="p">[</span><span class="n">where_we_have_not_improved</span><span class="p">]</span>
            <span class="n">d_prev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">d_curr</span><span class="p">)</span>

            <span class="n">d_curr_sum</span> <span class="o">=</span> <span class="n">d_curr</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="c1"># if the mask didn&#39;t obliterate all distance information, then</span>
            <span class="c1"># pick a datapoint at random with prob proportional to its squared</span>
            <span class="c1"># distance from the current cluster set</span>
            <span class="k">if</span> <span class="n">d_curr_sum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">datapoint_indices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">d_curr</span><span class="o">/</span><span class="n">d_curr_sum</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># then the mask obliterated all distance information, so just</span>
                <span class="c1"># pick one uniformly at random that&#39;s not already been chosen</span>
                <span class="n">available_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">datapoint_indices</span><span class="p">))</span>
                <span class="n">datapoint_indices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">available_indices</span><span class="p">))</span>
            <span class="c1"># finally, assign the cluster, either by setting all P entires</span>
            <span class="n">datapoints</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">datapoint_indices</span><span class="p">[</span><span class="n">k</span><span class="p">]]]</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">RHDX</span><span class="p">[</span><span class="n">datapoint_indices</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">datapoints</span><span class="p">,</span> <span class="n">datapoint_indices</span><span class="p">]</span>


    <span class="k">def</span> <span class="nf">_pick_K_dense_datapoints_random</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Picks K datapoints at random. If the Sparsifier has access to HDX,</span>
<span class="sd">        it will choose from that; otherwise draws from RHDX and returns a dense</span>
<span class="sd">        vector (with zeros outside the mask). &quot;&quot;&quot;</span>
        <span class="c1"># pick K data points at random uniformly</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
        <span class="n">datapoint_indices</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">datapoint_indices</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">datapoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">K</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">num_feat_full</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
            <span class="n">datapoints</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">datapoint_indices</span><span class="p">[</span><span class="n">k</span><span class="p">]]]</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">RHDX</span><span class="p">[</span><span class="n">datapoint_indices</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">datapoints</span><span class="p">,</span> <span class="n">datapoint_indices</span><span class="p">]</span>



    <span class="k">def</span> <span class="nf">_initialize_num_feat_full</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_feat_full</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_feat_full</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">)</span> <span class="ow">and</span> <span class="n">num_feat_full</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_full</span> <span class="o">=</span> <span class="n">num_feat_full</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;num_feat_full must be a positive integer, but is </span><span class="si">{num_feat_full}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_num_samp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_samp</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_samp</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">)</span> <span class="ow">and</span> <span class="n">num_samp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_samp</span> <span class="o">=</span> <span class="n">num_samp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;num_samp must be a positive integer, but is </span><span class="si">{num_samp}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_num_feat_comp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_feat_comp</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_feat_full</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_feat_comp</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">)</span> <span class="ow">and</span> <span class="n">num_feat_comp</span> <span class="o">&lt;=</span> <span class="n">num_feat_full</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_comp</span> <span class="o">=</span> <span class="n">num_feat_comp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;num_feat_comp must be None or an integer &lt; num_feat_full = </span><span class="si">{num_feat_full}</span><span class="s2">, but is </span><span class="si">{num_feat_comp}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_num_feat_shared</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_feat_shared</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_feat_full</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_feat_shared</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">)</span> <span class="ow">and</span> <span class="n">num_feat_shared</span> <span class="o">&lt;=</span> <span class="n">num_feat_full</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_feat_shared</span> <span class="o">=</span> <span class="n">num_feat_shared</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;num_feat_shared must be None or an integer &lt; num_feat_full = </span><span class="si">{num_feat_full}</span><span class="s2">, but is </span><span class="si">{num_feat_shared}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_D_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">D_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">num_feat_full</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">D_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_D_indices</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">D_indices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="c1">#TODO: check max, min, len, unique, integral</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D_indices</span> <span class="o">=</span> <span class="n">D_indices</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;D_indices is type {type(num_feat_shared)}; must be array of integers or none.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_random_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">seed</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">mtrand</span><span class="o">.</span><span class="n">_rand</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="p">(</span><span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">seed</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{seed}</span><span class="s2"> cannot be used to seed a numpy.random.RandomState&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">transform</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;dct&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Transform must be one of [None, &#39;dct&#39;], but is </span><span class="si">{transform}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">transform</span>

    <span class="k">def</span> <span class="nf">_initialize_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_mask</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1">#TODO: check size, sorted, etc.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Mask must be None or array of integers; but is type {type(mask)}.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_feat_full</span><span class="p">,</span> <span class="n">num_feat_comp</span><span class="p">,</span> <span class="n">num_samp</span><span class="p">,</span>
                 <span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">transform</span> <span class="o">=</span> <span class="s1">&#39;dct&#39;</span><span class="p">,</span> <span class="n">D_indices</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">num_feat_shared</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">random_state</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_transform</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_num_feat_full</span><span class="p">(</span><span class="n">num_feat_full</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_num_feat_comp</span><span class="p">(</span><span class="n">num_feat_comp</span><span class="p">,</span> <span class="n">num_feat_full</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_num_feat_shared</span><span class="p">(</span><span class="n">num_feat_shared</span><span class="p">,</span> <span class="n">num_feat_full</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_num_samp</span><span class="p">(</span><span class="n">num_samp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_D_indices</span><span class="p">(</span><span class="n">D_indices</span><span class="p">,</span> <span class="n">num_feat_full</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">sparseklearn</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparsifier.html">The Sparsifier Object</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gmm.html">Gaussian Mixture Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kmeans.html">K-Means</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Eric Kightley.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>